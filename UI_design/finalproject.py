# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'finalproject.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import pyqtSlot
from PyQt5.uic import loadUi
from PyQt5.QtGui import QImage, QPixmap
from PyQt5.QtWidgets import QDialog, QApplication
from imutils.video import VideoStream
from pyzbar import pyzbar
import argparse
import datetime
import imutils
import time
import sys, os
import cv2
import csv
from apscheduler.schedulers.background import BackgroundScheduler
import paho.mqtt.client as mqtt
import random
import json
from dbr import *


class Ui_mainWindow(object):
    def setupUi(self, mainWindow):
        mainWindow.setObjectName("mainWindow")
        mainWindow.resize(830, 644)
        self.centralwidget = QtWidgets.QWidget(mainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.cam1btn = QtWidgets.QPushButton(self.centralwidget)
        self.cam1btn.setGeometry(QtCore.QRect(530, 70, 70, 30))
        self.cam1btn.setObjectName("cam1btn")
        self.cam2btn = QtWidgets.QPushButton(self.centralwidget)
        self.cam2btn.setGeometry(QtCore.QRect(440, 70, 70, 30))
        self.cam2btn.setObjectName("cam2btn")
        self.cam3btn = QtWidgets.QPushButton(self.centralwidget)
        self.cam3btn.setGeometry(QtCore.QRect(360, 70, 70, 30))
        self.cam3btn.setObjectName("cam3btn")
        self.cam4btn = QtWidgets.QPushButton(self.centralwidget)
        self.cam4btn.setGeometry(QtCore.QRect(270, 70, 70, 30))
        self.cam4btn.setObjectName("cam4btn")
        self.cam5btn = QtWidgets.QPushButton(self.centralwidget)
        self.cam5btn.setGeometry(QtCore.QRect(180, 70, 70, 30))
        self.cam5btn.setObjectName("cam5btn")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(40, 250, 400, 350))
        self.label.setFrameShape(QtWidgets.QFrame.WinPanel)
        self.label.setLineWidth(0)
        self.label.setText("")
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(20, 110, 721, 131))
        self.label_2.setText("")
        self.label_2.setPixmap(QtGui.QPixmap("321.png"))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(480, 320, 58, 15))
        self.label_3.setObjectName("label_3")
        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setGeometry(QtCore.QRect(480, 390, 58, 15))
        self.label_4.setObjectName("label_4")
        self.spbtn = QtWidgets.QPushButton(self.centralwidget)
        self.spbtn.setGeometry(QtCore.QRect(80, 70, 81, 31))
        self.spbtn.setObjectName("spbtn")
        # self.ipbtn = QtWidgets.QPushButton(self.centralwidget)
        # self.ipbtn.setGeometry(QtCore.QRect(660, 570, 141, 41))
        # self.ipbtn.setObjectName("ipbtn")
        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)
        self.textBrowser.setGeometry(QtCore.QRect(550, 310, 111, 41))
        font = QtGui.QFont()
        font.setFamily("3ds Light")
        font.setPointSize(14)
        self.textBrowser.setFont(font)
        self.textBrowser.setObjectName("textBrowser")
        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)
        self.textBrowser_2.setGeometry(QtCore.QRect(550, 380, 241, 171))
        font = QtGui.QFont()
        font.setFamily("3ds Light")
        font.setPointSize(12)
        self.textBrowser_2.setFont(font)
        self.textBrowser_2.setObjectName("textBrowser_2")
        mainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(mainWindow)
        self.statusbar.setObjectName("statusbar")
        mainWindow.setStatusBar(self.statusbar)


        self.cam1btn.clicked.connect(self.cam1)
        self.cam2btn.clicked.connect(self.cam2)
        self.cam3btn.clicked.connect(self.cam3)
        self.cam4btn.clicked.connect(self.cam4)
        self.cam5btn.clicked.connect(self.cam5)
        self.spbtn.clicked.connect(self.sp)
        # self.ipbtn.clicked.connect(self.ip)



        self.retranslateUi(mainWindow)
        QtCore.QMetaObject.connectSlotsByName(mainWindow)

    def retranslateUi(self, mainWindow):
        _translate = QtCore.QCoreApplication.translate
        mainWindow.setWindowTitle(_translate("mainWindow", "TagIdentification"))
        self.cam1btn.setText(_translate("mainWindow", "cam1"))
        self.cam2btn.setText(_translate("mainWindow", "cam2"))
        self.cam3btn.setText(_translate("mainWindow", "cam3"))
        self.cam4btn.setText(_translate("mainWindow", "cam4"))
        self.cam5btn.setText(_translate("mainWindow", "cam5"))
        self.label_3.setText(_translate("mainWindow", "相機位置"))
        self.label_4.setText(_translate("mainWindow", "辨識結果"))
        self.spbtn.setText(_translate("mainWindow", "拼接"))
        # self.ipbtn.setText(_translate("mainWindow", "輸出"))

    def cam1(self):
        
        # 建立引數解析器，解析引數
        ap = argparse.ArgumentParser()
        ap.add_argument("-o", "--output", type=str, default="barcodes.csv",
                help="path to output CSV file containing barcodes")
        args = vars(ap.parse_args())

        # 設定MQTT傳輸的IP、port及Topic，並連線
        _g_cst_ToMQTTTopicServerIP = "127.0.0.1"
        _g_cst_ToMQTTTopicServerPort = 1883
        _g_cst_MQTTTopicName = "Label"
        mqttc = mqtt.Client("python_pub")
        mqttc.connect(_g_cst_ToMQTTTopicServerIP, _g_cst_ToMQTTTopicServerPort)

        # 初始化視訊
        print("[INFO] starting video stream...")
        vs = VideoStream(src=0).start()
        # vs = VideoStream(usePiCamera=True).start() 樹梅派
        time.sleep(2.0)

        # 開啟輸出CSV檔案，用來寫入掃描到的條碼
        csv = open(args["output"], "w")
        found = set()


        # 當讀到新的barcode值會寫入資料夾的暫存barcodes.csv及MQTT發送到出去
        sched = BackgroundScheduler(daemon=True)
        # 設定起始barcode值
        barcodeData = "start"


        def my_job():
            if barcodeData not in found:
                csv.write("{},{}\n".format(datetime.datetime.now(), barcodeData))
                csv.flush()
                found.add(barcodeData)
                print(json.dumps(barcodeData))
                mqttc.publish(_g_cst_MQTTTopicName, json.dumps(barcodeData))


        sched.add_job(lambda: my_job(), 'interval', seconds=1)
        sched.start()

        # 迴圈來自視訊流的幀
        while True:
            # 抓取來自單執行緒視訊流的幀，
            # 將大小調整為最大寬度600畫素
            self.textBrowser.setText("cam1")
            frame = vs.read()
            frame = imutils.resize(frame, width=600)

            # 找到視訊中的條碼，並解析條碼
            barcodes = pyzbar.decode(frame)
            # 迴圈檢測到的條形碼
            for barcode in barcodes:
             # 提取條碼的邊界框位置
             # 繪出條碼的邊界框
                (x, y, w, h) = barcode.rect
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2)

                # 繪出影象上的條碼的解碼結果和條碼類別
                barcodeData = barcode.data.decode("utf-8")
                barcodeType = barcode.type
                text = "{} ({})".format(barcodeData, barcodeType)
                cv2.putText(frame, text, (x, y - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
                self.textBrowser_2.setText(text)

        # 展示輸出幀
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            image = QImage(frame, frame.shape[1], frame.shape[0], QImage.Format_Indexed8)
            pixmap = QPixmap.fromImage(image)
            self.label.setPixmap(pixmap)
            # cv2.imshow("Barcode Scanner", frame)
            # key = cv2.waitKey(1) & 0xFF

            # # 如果按下”q”鍵就停止迴圈
            # if key == ord("q"):
            #     break

        # 關閉輸出後刪除暫存的CSV檔案
        print("[INFO] cleaning up...")
        csv.close()
        cv2.destroyAllWindows()
        vs.stop()


    def cam2(self):

        # 建立引數解析器，解析引數
        ap = argparse.ArgumentParser()
        ap.add_argument("-o", "--output", type=str, default="barcodes.csv",
                help="path to output CSV file containing barcodes")
        args = vars(ap.parse_args())

        # 設定MQTT傳輸的IP、port及Topic，並連線
        _g_cst_ToMQTTTopicServerIP = "127.0.0.1"
        _g_cst_ToMQTTTopicServerPort = 1883
        _g_cst_MQTTTopicName = "Label"
        mqttc = mqtt.Client("python_pub")
        mqttc.connect(_g_cst_ToMQTTTopicServerIP, _g_cst_ToMQTTTopicServerPort)

        # 初始化視訊
        print("[INFO] starting video stream...")
        vs = VideoStream(src=1).start()
        # vs = VideoStream(usePiCamera=True).start() 樹梅派
        time.sleep(2.0)

        # 開啟輸出CSV檔案，用來寫入掃描到的條碼
        csv = open(args["output"], "w")
        found = set()


        # 當讀到新的barcode值會寫入資料夾的暫存barcodes.csv及MQTT發送到出去
        sched = BackgroundScheduler(daemon=True)
        # 設定起始barcode值
        barcodeData = "start"


        def my_job():
            if barcodeData not in found:
                csv.write("{},{}\n".format(datetime.datetime.now(), barcodeData))
                csv.flush()
                found.add(barcodeData)
                print(json.dumps(barcodeData))
                mqttc.publish(_g_cst_MQTTTopicName, json.dumps(barcodeData))


        sched.add_job(lambda: my_job(), 'interval', seconds=1)
        sched.start()

        # 迴圈來自視訊流的幀
        while True:
            # 抓取來自單執行緒視訊流的幀，
            # 將大小調整為最大寬度600畫素
            self.textBrowser.setText("cam2")
            frame = vs.read()
            frame = imutils.resize(frame, width=600)

            # 找到視訊中的條碼，並解析條碼
            barcodes = pyzbar.decode(frame)
            # 迴圈檢測到的條形碼
            for barcode in barcodes:
             # 提取條碼的邊界框位置
             # 繪出條碼的邊界框
                (x, y, w, h) = barcode.rect
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2)

                # 繪出影象上的條碼的解碼結果和條碼類別
                barcodeData = barcode.data.decode("utf-8")
                barcodeType = barcode.type
                text = "{} ({})".format(barcodeData, barcodeType)
                cv2.putText(frame, text, (x, y - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
                self.textBrowser_2.setText(text)

        # 展示輸出幀
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            image = QImage(frame, frame.shape[1], frame.shape[0], QImage.Format_Indexed8)
            pixmap = QPixmap.fromImage(image)
            self.label.setPixmap(pixmap)
            # cv2.imshow("Barcode Scanner", frame)
            # results = dbr.decodeBuffer(frame, 0x3FF | 0x2000000 | 0x4000000 | 0x8000000 | 0x10000000)
            # out = ''
            # index = 0
            # for result in results:
            #     out += "Index: " + str(index) + "\n"
            #     out += "Barcode format: " + result[0] + '\n'
            #     out += "Barcode value: " + result[1] + '\n'
            #     out += '-----------------------------------\n'
            #     index += 1
 
            
            # key = cv2.waitKey(1) & 0xFF

            # # 如果按下”q”鍵就停止迴圈
            # if key == ord("q"):
            #     break

        # 關閉輸出後刪除暫存的CSV檔案
        print("[INFO] cleaning up...")
        csv.close()
        cv2.destroyAllWindows()
        vs.stop()


    def cam3(self):
        self.textBrowser.setText("cam3")
        # 建立引數解析器，解析引數
        ap = argparse.ArgumentParser()
        ap.add_argument("-o", "--output", type=str, default="barcodes.csv",
                help="path to output CSV file containing barcodes")
        args = vars(ap.parse_args())

        # 設定MQTT傳輸的IP、port及Topic，並連線
        _g_cst_ToMQTTTopicServerIP = "127.0.0.1"
        _g_cst_ToMQTTTopicServerPort = 1883
        _g_cst_MQTTTopicName = "Label"
        mqttc = mqtt.Client("python_pub")
        mqttc.connect(_g_cst_ToMQTTTopicServerIP, _g_cst_ToMQTTTopicServerPort)

        # 初始化視訊
        print("[INFO] starting video stream...")
        vs = VideoStream(src=2).start()
        # vs = VideoStream(usePiCamera=True).start() 樹梅派
        time.sleep(2.0)

        # 開啟輸出CSV檔案，用來寫入掃描到的條碼
        csv = open(args["output"], "w")
        found = set()


        # 當讀到新的barcode值會寫入資料夾的暫存barcodes.csv及MQTT發送到出去
        sched = BackgroundScheduler(daemon=True)
        # 設定起始barcode值
        barcodeData = "start"


        def my_job():
            if barcodeData not in found:
                csv.write("{},{}\n".format(datetime.datetime.now(), barcodeData))
                csv.flush()
                found.add(barcodeData)
                print(json.dumps(barcodeData))
                mqttc.publish(_g_cst_MQTTTopicName, json.dumps(barcodeData))


        sched.add_job(lambda: my_job(), 'interval', seconds=1)
        sched.start()

        # 迴圈來自視訊流的幀
        while True:
            # 抓取來自單執行緒視訊流的幀，
            # 將大小調整為最大寬度600畫素
            self.textBrowser.setText("cam2")
            frame = vs.read()
            frame = imutils.resize(frame, width=600)

            # 找到視訊中的條碼，並解析條碼
            barcodes = pyzbar.decode(frame)
            # 迴圈檢測到的條形碼
            for barcode in barcodes:
             # 提取條碼的邊界框位置
             # 繪出條碼的邊界框
                (x, y, w, h) = barcode.rect
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2)

                # 繪出影象上的條碼的解碼結果和條碼類別
                barcodeData = barcode.data.decode("utf-8")
                barcodeType = barcode.type
                text = "{} ({})".format(barcodeData, barcodeType)
                cv2.putText(frame, text, (x, y - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
                self.textBrowser_2.setText(text)

        # 展示輸出幀
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            image = QImage(frame, frame.shape[1], frame.shape[0], QImage.Format_Indexed8)
            pixmap = QPixmap.fromImage(image)
            self.label.setPixmap(pixmap)
            # cv2.imshow("Barcode Scanner", frame)
            # key = cv2.waitKey(1) & 0xFF

            # # 如果按下”q”鍵就停止迴圈
            # if key == ord("q"):
            #     break

        # 關閉輸出後刪除暫存的CSV檔案
        print("[INFO] cleaning up...")
        csv.close()
        cv2.destroyAllWindows()
        vs.stop()



    def cam4(self):
        self.textBrowser.setText("cam4")
        # 建立引數解析器，解析引數
        ap = argparse.ArgumentParser()
        ap.add_argument("-o", "--output", type=str, default="barcodes.csv",
                help="path to output CSV file containing barcodes")
        args = vars(ap.parse_args())

        # 設定MQTT傳輸的IP、port及Topic，並連線
        _g_cst_ToMQTTTopicServerIP = "127.0.0.1"
        _g_cst_ToMQTTTopicServerPort = 1883
        _g_cst_MQTTTopicName = "Label"
        mqttc = mqtt.Client("python_pub")
        mqttc.connect(_g_cst_ToMQTTTopicServerIP, _g_cst_ToMQTTTopicServerPort)

        # 初始化視訊
        print("[INFO] starting video stream...")
        vs = VideoStream(src=3).start()
        # vs = VideoStream(usePiCamera=True).start() 樹梅派
        time.sleep(2.0)

        # 開啟輸出CSV檔案，用來寫入掃描到的條碼
        csv = open(args["output"], "w")
        found = set()


        # 當讀到新的barcode值會寫入資料夾的暫存barcodes.csv及MQTT發送到出去
        sched = BackgroundScheduler(daemon=True)
        # 設定起始barcode值
        barcodeData = "start"


        def my_job():
            if barcodeData not in found:
                csv.write("{},{}\n".format(datetime.datetime.now(), barcodeData))
                csv.flush()
                found.add(barcodeData)
                print(json.dumps(barcodeData))
                mqttc.publish(_g_cst_MQTTTopicName, json.dumps(barcodeData))


        sched.add_job(lambda: my_job(), 'interval', seconds=1)
        sched.start()

        # 迴圈來自視訊流的幀
        while True:
            # 抓取來自單執行緒視訊流的幀，
            # 將大小調整為最大寬度600畫素
            self.textBrowser.setText("cam2")
            frame = vs.read()
            frame = imutils.resize(frame, width=600)

            # 找到視訊中的條碼，並解析條碼
            barcodes = pyzbar.decode(frame)
            # 迴圈檢測到的條形碼
            for barcode in barcodes:
             # 提取條碼的邊界框位置
             # 繪出條碼的邊界框
                (x, y, w, h) = barcode.rect
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2)

                # 繪出影象上的條碼的解碼結果和條碼類別
                barcodeData = barcode.data.decode("utf-8")
                barcodeType = barcode.type
                text = "{} ({})".format(barcodeData, barcodeType)
                cv2.putText(frame, text, (x, y - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
                self.textBrowser_2.setText(text)


        # 展示輸出幀
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            image = QImage(frame, frame.shape[1], frame.shape[0], QImage.Format_Indexed8)
            pixmap = QPixmap.fromImage(image)
            self.label.setPixmap(pixmap)
            # cv2.imshow("Barcode Scanner", frame)
            # key = cv2.waitKey(1) & 0xFF

            # # 如果按下”q”鍵就停止迴圈
            # if key == ord("q"):
            #     break

        # 關閉輸出後刪除暫存的CSV檔案
        print("[INFO] cleaning up...")
        csv.close()
        cv2.destroyAllWindows()
        vs.stop()



    def cam5(self):
        self.textBrowser.setText("cam5")
        # 建立引數解析器，解析引數
        ap = argparse.ArgumentParser()
        ap.add_argument("-o", "--output", type=str, default="barcodes.csv",
                help="path to output CSV file containing barcodes")
        args = vars(ap.parse_args())

        # 設定MQTT傳輸的IP、port及Topic，並連線
        _g_cst_ToMQTTTopicServerIP = "127.0.0.1"
        _g_cst_ToMQTTTopicServerPort = 1883
        _g_cst_MQTTTopicName = "Label"
        mqttc = mqtt.Client("python_pub")
        mqttc.connect(_g_cst_ToMQTTTopicServerIP, _g_cst_ToMQTTTopicServerPort)

        # 初始化視訊
        print("[INFO] starting video stream...")
        vs = VideoStream(src=4).start()
        # vs = VideoStream(usePiCamera=True).start() 樹梅派
        time.sleep(2.0)

        # 開啟輸出CSV檔案，用來寫入掃描到的條碼
        csv = open(args["output"], "w")
        found = set()


        # 當讀到新的barcode值會寫入資料夾的暫存barcodes.csv及MQTT發送到出去
        sched = BackgroundScheduler(daemon=True)
        # 設定起始barcode值
        barcodeData = "start"


        def my_job():
            if barcodeData not in found:
                csv.write("{},{}\n".format(datetime.datetime.now(), barcodeData))
                csv.flush()
                found.add(barcodeData)
                print(json.dumps(barcodeData))
                mqttc.publish(_g_cst_MQTTTopicName, json.dumps(barcodeData))


        sched.add_job(lambda: my_job(), 'interval', seconds=1)
        sched.start()

        # 迴圈來自視訊流的幀
        while True:
            # 抓取來自單執行緒視訊流的幀，
            # 將大小調整為最大寬度600畫素
            self.textBrowser.setText("cam2")
            frame = vs.read()
            frame = imutils.resize(frame, width=600)

            # 找到視訊中的條碼，並解析條碼
            barcodes = pyzbar.decode(frame)
            # 迴圈檢測到的條形碼
            for barcode in barcodes:
             # 提取條碼的邊界框位置
             # 繪出條碼的邊界框
                (x, y, w, h) = barcode.rect
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2)

                # 繪出影象上的條碼的解碼結果和條碼類別
                barcodeData = barcode.data.decode("utf-8")
                barcodeType = barcode.type
                text = "{} ({})".format(barcodeData, barcodeType)
                cv2.putText(frame, text, (x, y - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
                self.textBrowser_2.setText(text)

        # 展示輸出幀
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            image = QImage(frame, frame.shape[1], frame.shape[0], QImage.Format_Indexed8)
            pixmap = QPixmap.fromImage(image)
            self.label.setPixmap(pixmap)
            # cv2.imshow("Barcode Scanner", frame)
            # key = cv2.waitKey(1) & 0xFF

            # # 如果按下”q”鍵就停止迴圈
            # if key == ord("q"):
            #     break

        # 關閉輸出後刪除暫存的CSV檔案
        print("[INFO] cleaning up...")
        csv.close()
        cv2.destroyAllWindows()
        vs.stop()



    def sp(self):
        self.textBrowser.setText("拼接")
        global info
        # 根據config檔案中設定的邊界，對圖片投影變換
        for n, img in enumerate(images):
            src_contour = info[n]['perspective']['src']
            width = info[n]['perspective']['width']
            hight = info[n]['perspective']['hight']

            pts1 = np.float32(src_contour)
            pts2 = np.float32([(0, 0), (0, hight), (width, hight), (width, 0)])
            M = cv2.getPerspectiveTransform(pts1, pts2)
            dst = cv2.warpPerspective(img, M, (width, hight))
            images[n] = dst

        # 將圖片按照設定的位置水平拼接，組成完成圖
        for n, img in enumerate(images):
            front = info[n]['concat_x']['front']
            back = info[n]['concat_x']['back']

            images[n] = img[:, front:back, :]

        return cv2.hconcat(images)



    # def ip(self):


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    mainWindow = QtWidgets.QMainWindow()
    ui = Ui_mainWindow()
    ui.setupUi(mainWindow)
    mainWindow.show()
    sys.exit(app.exec_())
